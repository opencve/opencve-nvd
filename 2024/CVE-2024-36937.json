{
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nxdp: use flags field to disambiguate broadcast redirect\n\nWhen redirecting a packet using XDP, the bpf_redirect_map() helper will set\nup the redirect destination information in struct bpf_redirect_info (using\nthe __bpf_xdp_redirect_map() helper function), and the xdp_do_redirect()\nfunction will read this information after the XDP program returns and pass\nthe frame on to the right redirect destination.\n\nWhen using the BPF_F_BROADCAST flag to do multicast redirect to a whole\nmap, __bpf_xdp_redirect_map() sets the 'map' pointer in struct\nbpf_redirect_info to point to the destination map to be broadcast. And\nxdp_do_redirect() reacts to the value of this map pointer to decide whether\nit's dealing with a broadcast or a single-value redirect. However, if the\ndestination map is being destroyed before xdp_do_redirect() is called, the\nmap pointer will be cleared out (by bpf_clear_redirect_map()) without\nwaiting for any XDP programs to stop running. This causes xdp_do_redirect()\nto think that the redirect was to a single target, but the target pointer\nis also NULL (since broadcast redirects don't have a single target), so\nthis causes a crash when a NULL pointer is passed to dev_map_enqueue().\n\nTo fix this, change xdp_do_redirect() to react directly to the presence of\nthe BPF_F_BROADCAST flag in the 'flags' value in struct bpf_redirect_info\nto disambiguate between a single-target and a broadcast redirect. And only\nread the 'map' pointer if the broadcast flag is set, aborting if that has\nbeen cleared out in the meantime. This prevents the crash, while keeping\nthe atomic (cmpxchg-based) clearing of the map pointer itself, and without\nadding any more checks in the non-broadcast fast path."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: xdp: use el campo flags para eliminar la ambigüedad de la redirección de transmisión Al redireccionar un paquete usando XDP, el asistente bpf_redirect_map() configurará la información del destino de redireccionamiento en la estructura bpf_redirect_info (usando el asistente __bpf_xdp_redirect_map() función), y la función xdp_do_redirect() leerá esta información después de que el programa XDP regrese y pasará el framework al destino de redireccionamiento correcto. Cuando se utiliza el indicador BPF_F_BROADCAST para realizar una redirección de multidifusión a un mapa completo, __bpf_xdp_redirect_map() establece el puntero 'mapa' en la estructura bpf_redirect_info para que apunte al mapa de destino que se va a transmitir. Y xdp_do_redirect() reacciona al valor de este puntero de mapa para decidir si se trata de una transmisión o una redirección de valor único. Sin embargo, si el mapa de destino se destruye antes de llamar a xdp_do_redirect(), el puntero del mapa se borrará (mediante bpf_clear_redirect_map()) sin esperar a que deje de ejecutarse ningún programa XDP. Esto hace que xdp_do_redirect() piense que la redirección fue a un único objetivo, pero el puntero de destino también es NULL (dado que las redirecciones de difusión no tienen un único objetivo), por lo que esto provoca un bloqueo cuando se pasa un puntero NULL a dev_map_enqueue( ). Para solucionar este problema, cambie xdp_do_redirect() para reaccionar directamente a la presencia del indicador BPF_F_BROADCAST en el valor 'flags' en la estructura bpf_redirect_info para eliminar la ambigüedad entre un redireccionamiento de destino único y de transmisión. Y solo lea el puntero del 'mapa' si la bandera de transmisión está activada, abortando si se ha borrado mientras tanto. Esto evita el bloqueo, manteniendo al mismo tiempo la limpieza atómica (basada en cmpxchg) del puntero del mapa y sin agregar más comprobaciones en la ruta rápida sin transmisión."
    }
  ],
  "id": "CVE-2024-36937",
  "lastModified": "2024-05-30T18:18:58.870",
  "metrics": {},
  "published": "2024-05-30T16:15:16.797",
  "references": [
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/12481f30128fbebc2eeb55eb2d56390fdfa30c5e"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/272bfb019f3cc018f654b992115774e77b4f3ffc"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/5bcf0dcbf9066348058b88a510c57f70f384c92c"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/6fd81f9d333e7b3532036577b1beb74ba1323553"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/e22e25820fa04ea5eaac4ef7ee200e9923f466a4"
    }
  ],
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "vulnStatus": "Awaiting Analysis"
}