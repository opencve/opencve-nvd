{
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix writeback data corruption\n\ncifs writeback doesn't correctly handle the case where\ncifs_extend_writeback() hits a point where it is considering an additional\nfolio, but this would overrun the wsize - at which point it drops out of\nthe xarray scanning loop and calls xas_pause().  The problem is that\nxas_pause() advances the loop counter - thereby skipping that page.\n\nWhat needs to happen is for xas_reset() to be called any time we decide we\ndon't want to process the page we're looking at, but rather send the\nrequest we are building and start a new one.\n\nFix this by copying and adapting the netfslib writepages code as a\ntemporary measure, with cifs writeback intending to be offloaded to\nnetfslib in the near future.\n\nThis also fixes the issue with the use of filemap_get_folios_tag() causing\nretry of a bunch of pages which the extender already dealt with.\n\nThis can be tested by creating, say, a 64K file somewhere not on cifs\n(otherwise copy-offload may get underfoot), mounting a cifs share with a\nwsize of 64000, copying the file to it and then comparing the original file\nand the copy:\n\n        dd if=/dev/urandom of=/tmp/64K bs=64k count=1\n        mount //192.168.6.1/test /mnt -o user=...,pass=...,wsize=64000\n        cp /tmp/64K /mnt/64K\n        cmp /tmp/64K /mnt/64K\n\nWithout the fix, the cmp fails at position 64000 (or shortly thereafter)."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se resolvió la siguiente vulnerabilidad: cifs: corrige la corrupción de datos de reescritura cifs writeback no maneja correctamente el caso en el que cifs_extend_writeback() llega a un punto en el que está considerando una publicación adicional, pero esto sobrepasaría el tamaño de wsize - en momento en el que sale del ciclo de escaneo de xarray y llama a xas_pause(). El problema es que xas_pause() avanza el contador de bucle, omitiendo así esa página. Lo que debe suceder es que se llame a xas_reset() cada vez que decidamos que no queremos procesar la página que estamos viendo, sino enviar la solicitud que estamos creando y comenzar una nueva. Solucione este problema copiando y adaptando el código de escritura de netfslib como medida temporal, y la escritura diferida de cifs se descargará a netfslib en un futuro próximo. Esto también soluciona el problema con el uso de filemap_get_folios_tag() que provocaba un reintento de un grupo de páginas que el extensor ya había tratado. Esto se puede probar creando, por ejemplo, un archivo de 64 K en algún lugar que no esté en cif (de lo contrario, la descarga de copia podría complicarse), montando un recurso compartido cif con un tamaño de 64000, copiando el archivo en él y luego comparando el archivo original y la copia. : dd if=/dev/urandom of=/tmp/64K bs=64k count=1 mount //192.168.6.1/test /mnt -o user=...,pass=...,wsize=64000 cp /tmp /64K /mnt/64K cmp /tmp/64K /mnt/64K Sin la corrección, el cmp falla en la posición 64000 (o poco después)."
    }
  ],
  "id": "CVE-2024-27036",
  "lastModified": "2024-05-01T19:50:25.633",
  "metrics": {},
  "published": "2024-05-01T13:15:49.407",
  "references": [
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/65f2ced695982ccd516196d0a9447d85dbe2eed5"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/844b4e132f57f1333dc79feaa035075a096762e4"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/e45deec35bf7f1f4f992a707b2d04a8c162f2240"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/f3dc1bdb6b0b0693562c7c54a6c28bafa608ba3c"
    }
  ],
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "vulnStatus": "Awaiting Analysis"
}