{
  "cveTags": [],
  "descriptions": [
    {
      "lang": "en",
      "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nplatform/chrome: cros_ec_uart: properly fix race condition\n\nThe cros_ec_uart_probe() function calls devm_serdev_device_open() before\nit calls serdev_device_set_client_ops(). This can trigger a NULL pointer\ndereference:\n\n    BUG: kernel NULL pointer dereference, address: 0000000000000000\n    ...\n    Call Trace:\n     <TASK>\n     ...\n     ? ttyport_receive_buf\n\nA simplified version of crashing code is as follows:\n\n    static inline size_t serdev_controller_receive_buf(struct serdev_controller *ctrl,\n                                                      const u8 *data,\n                                                      size_t count)\n    {\n            struct serdev_device *serdev = ctrl->serdev;\n\n            if (!serdev || !serdev->ops->receive_buf) // CRASH!\n                return 0;\n\n            return serdev->ops->receive_buf(serdev, data, count);\n    }\n\nIt assumes that if SERPORT_ACTIVE is set and serdev exists, serdev->ops\nwill also exist. This conflicts with the existing cros_ec_uart_probe()\nlogic, as it first calls devm_serdev_device_open() (which sets\nSERPORT_ACTIVE), and only later sets serdev->ops via\nserdev_device_set_client_ops().\n\nCommit 01f95d42b8f4 (\"platform/chrome: cros_ec_uart: fix race\ncondition\") attempted to fix a similar race condition, but while doing\nso, made the window of error for this race condition to happen much\nwider.\n\nAttempt to fix the race condition again, making sure we fully setup\nbefore calling devm_serdev_device_open()."
    },
    {
      "lang": "es",
      "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: plataforma/chrome: cros_ec_uart: corrige correctamente la condición de ejecución. La función cros_ec_uart_probe() llama a devm_serdev_device_open() antes de llamar a serdev_device_set_client_ops(). Esto puede desencadenar una desreferencia del puntero NULL: ERROR: desreferencia del puntero NULL del kernel, dirección: 0000000000000000... Seguimiento de llamadas: ...? ttyport_receive_buf Una versión simplificada del código de bloqueo es la siguiente: static inline size_t serdev_controller_receive_buf(struct serdev_controller *ctrl, const u8 *data, size_t count) { struct serdev_device *serdev = ctrl-&gt;serdev; if (!serdev || !serdev-&gt;ops-&gt;receive_buf) // ¡CRASH! devolver 0; devolver serdev-&gt;ops-&gt;receive_buf(serdev, datos, recuento); } Se supone que si SERPORT_ACTIVE está configurado y serdev existe, serdev-&gt;ops también existirá. Esto entra en conflicto con la lógica cros_ec_uart_probe() existente, ya que primero llama a devm_serdev_device_open() (que configura SERPORT_ACTIVE), y solo luego configura serdev-&gt;ops a través de serdev_device_set_client_ops(). La confirmación 01f95d42b8f4 (\"plataforma/chrome: cros_ec_uart: arreglar condición de ejecución\") intentó arreglar una condición de ejecución similar, pero al hacerlo, hizo que la ventana de error para que esta condición de ejecución ocurriera fuera mucho más amplia. Intente corregir la condición de ejecución nuevamente, asegurándose de realizar la configuración completa antes de llamar a devm_serdev_device_open()."
    }
  ],
  "id": "CVE-2024-35977",
  "lastModified": "2024-05-20T13:00:04.957",
  "metrics": {},
  "published": "2024-05-20T10:15:12.340",
  "references": [
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/5e700b384ec13f5bcac9855cb28fcc674f1d3593"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/9e9bb74a93b7daa32313ccaefd0edc529d40daf8"
    },
    {
      "source": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
      "url": "https://git.kernel.org/stable/c/cfd758041d8b79aa8c3f811b6bd6105379f2f702"
    }
  ],
  "sourceIdentifier": "416baaa9-dc9f-4396-8d5f-8c081fb06d67",
  "vulnStatus": "Awaiting Analysis"
}